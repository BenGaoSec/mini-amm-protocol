// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import { IMiniAmmPool } from "../interfaces/IMiniAmmPool.sol";
import { IERC20Minimal } from "../interfaces/IERC20Minimal.sol";
import { AmmMath } from "../libraries/AmmMath.sol";
import { SafeTransferLib } from "../libraries/SafeTransferLib.sol";
import { ReentrancyGuard } from "../libraries/ReentrancyGuard.sol";

/// @title MiniAmmPool - x*y=k AMM for two ERC20 tokens
/// @notice Learning / internal project, NOT production-ready
contract MiniAmmPool is IMiniAmmPool, ReentrancyGuard {
    // ==========
    //  Errors
    // ==========
    // TODO: define custom errors (e.g., InsufficientLiquidity, InvalidAmount, etc.)

    // ==========
    //  Events
    // ==========
    // TODO: Mint, Burn, Swap, Sync
    event Transfer(address indexed from, address indexed to, uint256 value);
    event Approval(address indexed owner, address indexed spender, uint256 value);

    // ==========
    //  Constants (LP token metadata, etc.)
    // ==========
    string public constant name = "MINI-AMM-LP";
    string public constant symbol = "MLP";
    uint8 public constant decimals = 18;

    uint256 public constant MINIMUM_LIQUIDITY = 1_000;

    // ==========
    //  Immutable config (pool tokens)
    // ==========
    // Match IMiniAmmPool: token0() / token1() return address
    address public immutable override token0;
    address public immutable override token1;

    // ==========
    //  Storage - reserves & LP accounting
    // ==========
    uint112 private reserve0; // balance of token0, tracked
    uint112 private reserve1; // balance of token1, tracked

    uint256 public totalSupply;                         // LP total supply
    mapping(address => uint256) public balanceOf;       // LP balances
    mapping(address => mapping(address => uint256)) public allowance; // LP allowances

    // ==========
    //  Constructor
    // ==========
    constructor(address _token0, address _token1) {
        require(_token0 != _token1, "IDENTICAL_ADDRESSES");
        require(_token0 != address(0) && _token1 != address(0), "ZERO_ADDRESS");

        token0 = _token0;
        token1 = _token1;
    }

    // ==========
    //  External view functions (interface)
    // ==========
    function getReserves() external view override returns (uint112, uint112) {
        return (reserve0, reserve1);
    }

    // (token0() and token1() are auto-generated by the public immutable state
    //  variables above and satisfy the IMiniAmmPool interface.)

    // ==========
    //  Core external actions (AMM)
    // ==========

    /**
     * @notice User adds liquidity to the pool.
     * @dev amount0Desired / amount1Desired = max amounts user is willing to deposit.
     *      Contract will compute actual amount0 / amount1 based on current reserves.
     */
    function addLiquidity(
        uint256 amount0Desired,
        uint256 amount1Desired,
        uint256 amount0Min,
        uint256 amount1Min,
        address to
    )
        external
        override
        nonReentrant
        returns (uint256 amount0, uint256 amount1, uint256 liquidity)
    {
        require(to != address(0),"TO_ZERO");
        require(amount0Desired !=0 || amount1Desired != 0, "ZERO_INPUT");
        
        uint112 _reserve0 = reserve0;
        uint112 _reserve1 = reserve1;
        uint256 _totalSupply = totalSupply;

    // --------------------------------------------------------------------
    // Case A: bootstrap (first liquidity sets initial price)
    // --------------------------------------------------------------------





        

   
   
   



    }

    function removeLiquidity(
        uint256 liquidity,
        uint256 amount0Min,
        uint256 amount1Min,
        address to
    )
        external
        override
        nonReentrant
        returns (uint256 amount0, uint256 amount1)
    {
        // TODO: implement according to flowchart
    }

    function swap(
        uint256 amountIn,
        uint256 minAmountOut,
        bool zeroForOne,
        address to
    )
        external
        override
        nonReentrant
        returns (uint256 amountOut)
    {
        // TODO: implement according to flowchart
    }

    // ==========
    //  LP ERC20 interface (for LP token transfers)
    // ==========
    function transfer(address to, uint256 value) external returns (bool) {
        _transfer(msg.sender, to, value);
        return true;
    }

    function approve(address spender, uint256 value) external returns (bool) {
        allowance[msg.sender][spender] = value;
        emit Approval(msg.sender, spender, value);
        return true;
    }

    function transferFrom(address from, address to, uint256 value) external returns (bool) {
        uint256 allowed = allowance[from][msg.sender];
        require(allowed >= value, "INSUFFICIENT_ALLOWANCE");

        if (allowed != type(uint256).max) {
            unchecked {
                allowance[from][msg.sender] = allowed - value;
            }
        }

        _transfer(from, to, value);
        return true;
    }

    // ==========
    //  Internal helpers
    // ==========
    function _transfer(address from, address to, uint256 value) internal {
        require(from != address(0), "ADDRESS_FROM_ZERO");
        require(to != address(0), "ADDRESS_TO_ZERO");

        uint256 fromBalance = balanceOf[from];
        require(fromBalance >= value, "INSUFFICIENT_BALANCE");

        unchecked {
            balanceOf[from] = fromBalance - value;
        }
        balanceOf[to] += value;

        emit Transfer(from, to, value);
    }



    // TODO:
    // - _updateReserves(uint256 balance0, uint256 balance1)
    // - _mintLiquidity(address to, uint256 liquidity)
    // - _burnLiquidity(address from, uint256 liquidity)
    // - internal wrappers around SafeTransferLib for token0/token1
}
